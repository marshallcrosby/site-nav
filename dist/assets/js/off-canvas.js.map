{"version":3,"names":[],"mappings":"","sources":["off-canvas.js"],"sourcesContent":["class OffCanvasNav {\n    constructor(navElement) {\n        \n        // Find the main navigation elements\n        this.nav = navElement;\n        this.menu = navElement.querySelector('[data-oc-menu]');\n        this.overlay = navElement.querySelector('[data-oc-overlay]') || document.querySelector('[data-oc-overlay]');\n        this.toggleButton = navElement.querySelector('[data-oc-toggle]');\n        this.closeButton = navElement.querySelector('[data-oc-close]');\n        \n        // Track keyboard and focus state\n        this.keyboardHandler = null;\n        this.previouslyFocusedElement = null;\n        \n        // Touch/swipe state\n        this.touchStartX = 0;\n        this.touchStartY = 0;\n        this.touchCurrentX = 0;\n        this.touchCurrentY = 0;\n        this.isDragging = false;\n        this.swipeThreshold = 50;\n        this.swipeVelocityThreshold = 0.3;\n        this.snapThreshold = 0.5; // 50% threshold to determine snap direction\n        \n        // Gesture tracking\n        this.isGestureInProgress = false;\n        this.gestureStartPosition = 0;\n        \n        this.setupEventListeners();\n    }\n    \n    setupEventListeners() {\n        \n        // Open/close menu when toggle button is clicked\n        if (this.toggleButton) {\n            this.toggleButton.addEventListener('click', () => this.toggleMenu());\n        }\n        \n        // Close menu when close button is clicked\n        if (this.closeButton) {\n            this.closeButton.addEventListener('click', () => this.closeMenu());\n        }\n        \n        // Close menu when overlay is clicked\n        if (this.overlay) {\n            this.overlay.addEventListener('click', () => this.closeMenu());\n        }\n        \n        // Close menu when Escape key is pressed\n        document.addEventListener('keydown', (event) => {\n            if (event.key === 'Escape' && this.isMenuOpen()) {\n                this.closeMenu();\n            }\n        });\n        \n        // Handle window resize - close menu on desktop, manage accessibility on mobile\n        window.addEventListener('resize', () => {\n            if (this.isDesktopView()) {\n                this.closeMenu();\n                this.makeMenuAccessible();\n            } else {\n                this.updateAccessibilityForCurrentState();\n            }\n        });\n        \n        // Setup swipe functionality\n        this.setupSwipeListeners();\n        \n        // Set initial accessibility state\n        this.updateAccessibilityForCurrentState();\n    }\n    \n    getMenuWidth() {\n        return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--oc-menu-width'), 10);\n    }\n    \n    isMenuOnRight() {\n        return this.menu.classList.contains('oc-nav__menu--right');\n    }\n    \n    setMenuTransform(translateX) {\n        const isRight = this.isMenuOnRight();\n        const menuWidth = this.getMenuWidth();\n        \n        // Clamp the translation values for closing only\n        if (isRight) {\n            translateX = Math.min(0, Math.max(-menuWidth, translateX));\n        } else {\n            translateX = Math.max(0, Math.min(menuWidth, translateX));\n        }\n        \n        this.menu.style.transform = `translateX(${translateX}px)`;\n        \n        // Update overlay opacity based on menu position\n        if (this.overlay) {\n            const progress = Math.abs(translateX) / menuWidth;\n            this.overlay.style.opacity = progress;\n            this.overlay.style.visibility = progress > 0 ? 'visible' : 'hidden';\n        }\n    }\n    \n    resetMenuTransform() {\n        this.menu.style.transform = '';\n        if (this.overlay) {\n            this.overlay.style.opacity = '';\n            this.overlay.style.visibility = '';\n        }\n    }\n    \n    setupSwipeListeners() {\n        // Touch events for swipe functionality\n        document.addEventListener('touchstart', (e) => this.handleTouchStart(e), { passive: true });\n        document.addEventListener('touchmove', (e) => this.handleTouchMove(e), { passive: false });\n        document.addEventListener('touchend', (e) => this.handleTouchEnd(e), { passive: true });\n        \n        // Mouse events for desktop swipe simulation (optional)\n        document.addEventListener('mousedown', (e) => this.handleMouseStart(e));\n        document.addEventListener('mousemove', (e) => this.handleMouseMove(e));\n        document.addEventListener('mouseup', (e) => this.handleMouseEnd(e));\n    }\n    \n    handleTouchStart(e) {\n        if (!this.isMobileView() || !this.isMenuOpen()) return;\n        \n        this.touchStartX = e.touches[0].clientX;\n        this.touchStartY = e.touches[0].clientY;\n        this.touchCurrentX = this.touchStartX;\n        this.touchCurrentY = this.touchStartY;\n        this.isDragging = false;\n        this.isGestureInProgress = false;\n        this.swipeStartTime = Date.now();\n    }\n    \n    handleTouchMove(e) {\n        if (!this.isMobileView() || !this.isMenuOpen()) return;\n        \n        this.touchCurrentX = e.touches[0].clientX;\n        this.touchCurrentY = e.touches[0].clientY;\n        \n        const deltaX = this.touchCurrentX - this.touchStartX;\n        const deltaY = this.touchCurrentY - this.touchStartY;\n        \n        // Check if it's a horizontal swipe (more horizontal than vertical movement)\n        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {\n            const isRight = this.isMenuOnRight();\n            \n            // Only allow closing gestures\n            const isClosingGesture = isRight ? deltaX > 0 : deltaX < 0;\n            \n            if (isClosingGesture) {\n                this.isDragging = true;\n                this.isGestureInProgress = true;\n                \n                // Prevent scrolling when swiping horizontally\n                e.preventDefault();\n                \n                // Calculate the new position for closing\n                const menuWidth = this.getMenuWidth();\n                let newTranslateX;\n                \n                if (isRight) {\n                    // Right menu: positive deltaX closes (swipe right to close)\n                    newTranslateX = -menuWidth + deltaX;\n                } else {\n                    // Left menu: negative deltaX closes (swipe left to close)\n                    newTranslateX = menuWidth + deltaX;\n                }\n                \n                // Apply the transform in real-time\n                this.setMenuTransform(newTranslateX);\n            }\n        }\n    }\n    \n    handleTouchEnd(e) {\n        if (!this.isMobileView() || !this.isDragging || !this.isMenuOpen()) return;\n        \n        const deltaX = this.touchCurrentX - this.touchStartX;\n        const deltaY = this.touchCurrentY - this.touchStartY;\n        const swipeTime = Date.now() - this.swipeStartTime;\n        const swipeVelocity = Math.abs(deltaX) / swipeTime;\n        \n        // Check if it's a valid horizontal swipe\n        if (Math.abs(deltaX) > Math.abs(deltaY)) {\n            const isRight = this.isMenuOnRight();\n            const menuWidth = this.getMenuWidth();\n            \n            // Calculate how far the menu has been dragged as a percentage\n            const dragDistance = Math.abs(deltaX);\n            const dragPercentage = dragDistance / menuWidth;\n            \n            // Determine if we should close based on distance or velocity\n            let shouldClose = false;\n            \n            if (swipeVelocity > this.swipeVelocityThreshold) {\n                // Fast swipe - use direction (only allow closing direction)\n                if (isRight) {\n                    shouldClose = deltaX > 0; // Swipe right to close\n                } else {\n                    shouldClose = deltaX < 0; // Swipe left to close\n                }\n            } else {\n                // Slow swipe - use position threshold\n                shouldClose = dragPercentage > this.snapThreshold;\n            }\n            \n            // Animate to final position\n            this.menu.style.transition = 'transform 300ms cubic-bezier(0.25, 0.46, 0.45, 0.94)';\n            \n            if (shouldClose) {\n                this.snapToClose();\n            } else {\n                this.snapToOpen();\n            }\n            \n            // Remove transition after animation\n            setTimeout(() => {\n                this.menu.style.transition = '';\n            }, 300);\n        }\n        \n        this.isDragging = false;\n        this.isGestureInProgress = false;\n    }\n    \n    snapToOpen() {\n        const isRight = this.isMenuOnRight();\n        const menuWidth = this.getMenuWidth();\n        \n        // Set final transform for open state\n        if (isRight) {\n            this.setMenuTransform(-menuWidth);\n        } else {\n            this.setMenuTransform(menuWidth);\n        }\n        \n        // Reset transform after transition\n        setTimeout(() => {\n            this.resetMenuTransform();\n        }, 300);\n    }\n    \n    snapToClose() {\n        // Set final transform for closed state\n        this.setMenuTransform(0);\n        \n        // Update classes and accessibility\n        this.menu.classList.remove('show');\n        if (this.overlay) {\n            this.overlay.classList.remove('show');\n        }\n        \n        this.toggleButton.setAttribute('aria-expanded', 'false');\n        this.closeButton.setAttribute('aria-expanded', 'false');\n        \n        document.body.style.overflow = '';\n        this.updateAccessibilityForCurrentState();\n        this.removeKeyboardNavigation();\n        \n        // Reset transform after transition\n        setTimeout(() => {\n            this.resetMenuTransform();\n        }, 300);\n    }\n    \n    // Mouse event handlers for desktop swipe simulation\n    handleMouseStart(e) {\n        if (!this.isMobileView() || !this.isMenuOpen()) return;\n        \n        this.touchStartX = e.clientX;\n        this.touchStartY = e.clientY;\n        this.touchCurrentX = this.touchStartX;\n        this.touchCurrentY = this.touchStartY;\n        this.isDragging = false;\n        this.isGestureInProgress = false;\n        this.swipeStartTime = Date.now();\n        this.isMouseDown = true;\n    }\n    \n    handleMouseMove(e) {\n        if (!this.isMobileView() || !this.isMouseDown || !this.isMenuOpen()) return;\n        \n        this.touchCurrentX = e.clientX;\n        this.touchCurrentY = e.clientY;\n        \n        const deltaX = this.touchCurrentX - this.touchStartX;\n        const deltaY = this.touchCurrentY - this.touchStartY;\n        \n        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {\n            const isRight = this.isMenuOnRight();\n            \n            // Only allow closing gestures\n            const isClosingGesture = isRight ? deltaX > 0 : deltaX < 0;\n            \n            if (isClosingGesture) {\n                this.isDragging = true;\n                this.isGestureInProgress = true;\n                \n                // Calculate the new position for closing\n                const menuWidth = this.getMenuWidth();\n                let newTranslateX;\n                \n                if (isRight) {\n                    // Right menu: positive deltaX closes\n                    newTranslateX = -menuWidth + deltaX;\n                } else {\n                    // Left menu: negative deltaX closes\n                    newTranslateX = menuWidth + deltaX;\n                }\n                \n                this.setMenuTransform(newTranslateX);\n            }\n        }\n    }\n    \n    handleMouseEnd(e) {\n        if (!this.isMobileView() || !this.isMouseDown) return;\n        \n        if (this.isDragging) {\n            this.handleTouchEnd(e);\n        }\n        \n        this.isMouseDown = false;\n        this.isDragging = false;\n        this.isGestureInProgress = false;\n    }\n    \n    toggleMenu() {\n        if (this.isMenuOpen()) {\n            this.toggleButton.setAttribute('aria-expanded', 'false');\n            this.closeButton.setAttribute('aria-expanded', 'false');\n            this.closeMenu();\n        } else {\n            this.toggleButton.setAttribute('aria-expanded', 'true');\n            this.closeButton.setAttribute('aria-expanded', 'true');\n            this.openMenu();\n        }\n    }\n    \n    openMenu() {\n        this.toggleButton.setAttribute('aria-expanded', 'true');\n        this.closeButton.setAttribute('aria-expanded', 'true');\n        \n        // Fire a custom event after before transition starts\n        const showEvent = new CustomEvent('show.offCanvas');\n        document.dispatchEvent(showEvent);\n\n        // Show the menu and overlay\n        this.menu.classList.add('show');\n        \n        if (this.overlay) {\n            this.overlay.classList.add('show');\n        }\n        \n        // Prevent page scrolling when menu is open\n        document.body.style.overflow = 'hidden';\n        \n        // Handle accessibility and keyboard navigation\n        this.updateAccessibilityForCurrentState();\n        this.setupKeyboardNavigation();\n\n        // Fire a custom event after transition ends\n        this.menu.addEventListener('transitionend', () => {\n            const shownEvent = new CustomEvent('shown.offCanvas');\n            document.dispatchEvent(shownEvent);\n        }, { once: true });\n    }\n    \n    closeMenu() {\n        this.toggleButton.setAttribute('aria-expanded', 'false');\n        this.closeButton.setAttribute('aria-expanded', 'false');\n\n        // Fire a custom event after before transition starts\n        const hideEvent = new CustomEvent('hide.offCanvas');\n        document.dispatchEvent(hideEvent);\n        \n        // Hide the menu and overlay\n        this.menu.classList.remove('show');\n        \n        if (this.overlay) {\n            this.overlay.classList.remove('show');\n        }\n        \n        // Restore page scrolling\n        document.body.style.overflow = '';\n        \n        // Clean up accessibility and keyboard navigation\n        this.updateAccessibilityForCurrentState();\n        this.removeKeyboardNavigation();\n\n        // Fire a custom event after transition ends\n        this.menu.addEventListener('transitionend', () => {\n            const hiddenEvent = new CustomEvent('hidden.offCanvas');\n            document.dispatchEvent(hiddenEvent);\n        }, { once: true });\n    }\n    \n    isMenuOpen() {\n        return this.menu.classList.contains('show');\n    }\n    \n    isDesktopView() {\n        return window.matchMedia('(min-width: 992px)').matches;\n    }\n    \n    isMobileView() {\n        return window.matchMedia('(max-width: 991px)').matches;\n    }\n    \n    isElementVisible(element) {\n        const styles = window.getComputedStyle(element);\n        return styles.display !== 'none' && \n                styles.visibility !== 'hidden' && \n                element.offsetParent !== null;\n    }\n    \n    getFocusableElements(container) {\n        \n        // Define what elements can receive focus\n        const focusableSelectors = [\n            'a[href]',\n            'area[href]',\n            'input:not([disabled])',\n            'select:not([disabled])',\n            'textarea:not([disabled])',\n            'button:not([disabled])',\n            'iframe',\n            'object',\n            'embed',\n            '[tabindex=\"0\"]',\n            '[contenteditable]'\n        ];\n        \n        // Find all focusable elements that are actually visible\n        return Array.from(container.querySelectorAll(focusableSelectors.join(',')))\n            .filter(element => this.isElementVisible(element) && element.tabIndex >= 0);\n    }\n    \n    setupKeyboardNavigation() {\n        \n        // Remember what was focused before opening the menu\n        this.previouslyFocusedElement = document.activeElement;\n        \n        // Create keyboard event handler for the menu\n        this.keyboardHandler = (event) => {\n            \n            // Close menu on Escape\n            if (event.key === 'Escape') {\n                event.preventDefault();\n                this.closeMenu();\n                return;\n            }\n            \n            // Handle Tab navigation to stay within the menu\n            if (event.key === 'Tab') {\n                const focusableElements = this.getFocusableElements(this.menu);\n                const firstElement = focusableElements[0];\n                const lastElement = focusableElements[focusableElements.length - 1];\n                \n                // If no focusable elements, prevent tabbing\n                if (focusableElements.length === 0) {\n                    event.preventDefault();\n                    return;\n                }\n                \n                // Wrap focus from first to last when shift+tabbing\n                if (event.shiftKey && document.activeElement === firstElement) {\n                    event.preventDefault();\n                    lastElement.focus();\n                }\n                // Wrap focus from last to first when tabbing\n                else if (!event.shiftKey && document.activeElement === lastElement) {\n                    event.preventDefault();\n                    firstElement.focus();\n                }\n            }\n        };\n        \n        // Attach the keyboard handler to the menu\n        this.menu.addEventListener('keydown', this.keyboardHandler);\n        \n        // Focus the first focusable element in the menu\n        const firstFocusableElement = this.getFocusableElements(this.menu)[0];\n        if (firstFocusableElement) {\n            firstFocusableElement.focus();\n        }\n    }\n    \n    removeKeyboardNavigation() {\n        \n        // Remove the keyboard event handler\n        if (this.keyboardHandler) {\n            this.menu.removeEventListener('keydown', this.keyboardHandler);\n            this.keyboardHandler = null;\n        }\n        \n        // Restore focus to the element that was focused before opening the menu\n        if (this.previouslyFocusedElement) {\n            this.previouslyFocusedElement.focus();\n        }\n    }\n    \n    updateAccessibilityForCurrentState() {\n        \n        // On mobile when menu is open, make it accessible\n        // Otherwise, make it inaccessible to screen readers\n        if (this.isMenuOpen() && this.isMobileView() || !this.isMobileView()) {\n            this.makeMenuAccessible();\n        } else {\n            this.makeMenuInaccessible();\n        }\n    }\n    \n    makeMenuAccessible() {\n        this.menu.removeAttribute('inert');\n    }\n    \n    makeMenuInaccessible() {\n        this.menu.setAttribute('inert', 'true');\n    }\n}\n\n// Initialize navigation when the page loads\ndocument.addEventListener('DOMContentLoaded', () => {\n    const navigationElements = document.querySelectorAll('.oc-nav');\n    navigationElements.forEach(nav => new OffCanvasNav(nav));\n});"],"file":"off-canvas.js"}